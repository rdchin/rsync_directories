#!/bin/bash
#
# ©2024 Copyright 2024 Robert D. Chin
# Email: RDevChin@Gmail.com
#
# Usage: source server_rsync.lib
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# +----------------------------------------+
# |        Default Variable Values         |
# +----------------------------------------+
#
VERSION="2024-06-25 23:32"
#
# Commented out THIS_FILE since it will conflict other scripts which
# use this library.
#THIS_FILE="server_rsync.lib"
#
# +----------------------------------------+
# |            Brief Description           |
# +----------------------------------------+
#
#& Brief Description
#&
#& Library of BASH functions, server_rsync.lib is a child dependency
#& used by the following scripts.
#&
#& Parent script: server_rsync.sh.
#&
#& See script server_rsync.sh for Edit History.
#&
#& Usage: source server_rsync.lib
#&
#&    This program is free software: you can redistribute it and/or modify
#&    it under the terms of the GNU General Public License as published by
#&    the Free Software Foundation, either version 3 of the License, or
#&    (at your option) any later version.
#&
#&
#&    This program is distributed in the hope that it will be useful,
#&    but WITHOUT ANY WARRANTY; without even the implied warranty of
#&    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#&    GNU General Public License for more details.
#&
#&    You should have received a copy of the GNU General Public License
#&    along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# +----------------------------------------+
# |           Code Change History          |
# +----------------------------------------+
#
## Code Change History
##
## (Please see script "server_rsync.sh" for Code History information.)
#
# +--------------------------------------------------------------------------+
# |                                                                          |
# |                 Customize Menu choice options below.                     |
# |                                                                          |
# +--------------------------------------------------------------------------+
#
#
#                 >>> !!!Warning!!! <<<
#
# The Menu Item Descriptions cannot have semi-colons, colons, asterisks,
# single-quotes (apostrophes), double-quotes, ampersands, greater-than and less-than signs.
#
# Forbidden characters include ; : * ' " - & > < / \
#
# These characters will compromise the creation of arrays which
# in turn creates the menu.
#
# General Format: <#@@> <Menu Option> <#@@> <Description of Menu Option> <#@@> <Corresponding function or action or command>
#
# Format of <Corresponding function or action or command> when using f_create_a_menu
#        f_create_menu^"text", "dialog", or "whiptail"^menu_generated.lib^Menu Name^Temporary File Name^Library name containing menu entries
#
# List of inputs for f_create_a_menu.
#
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface application in use.
#          $2 - GENERATED_FILE (The name of a temporary library file containing the suggested phrase "generated.lib" which contains the code to display the sub-menu).
#          $3 - MENU_TITLE (Title of the sub-menu)
#          $4 - TEMP_FILE (Temporary file).
#          $5 - ARRAY_FILE (Temporary file) includes menu items imported from $ARRAY_SOURCE_FILE of a single menu.
#          $6 - ARRAY_SOURCE_FILE (Not a temporay file) includes menu items from multiple menus.
#
# Format: <#@@> <Menu Option> <#@@> <Description of Menu Option> <#@@> <Corresponding function or action or cammand>
#
#! +--------------------------------------------------------------+
#! | Start Listing Server Rsync Menu                              |
#! |               (Required header, do not delete).              |
#! +--------------------------------------------------------------+
#
#@@Exit#@@Exit this menu.#@@break
#
#@@Synchronize#@@Synchronize two directories.#@@f_any^$GUI
#
#@@Log-file#@@Show latest log file.#@@f_log_display^$GUI
#
#@@Local/LAN storage#@@Show local removable storage devices and LAN mount points.#@@f_show_mount_points^$GUI
#
#@@File Managers#@@Manage files and folders.#@@f_file_manager_select^$GUI^"/mnt"
#
#@@About#@@Version information of this script.#@@f_about^$GUI
#
#@@Code History#@@Display code change history of this script.#@@f_code_history^$GUI
#
#@@Version Update#@@Check for updates to this script and download.#@@f_check_version^$GUI
#
#@@Help Dir Trees#@@Display Source/Back-up directory trees.#@@f_help_directory_diagrams^$GUI
#
#@@Help#@@Display help message.#@@f_help_message^$GUI
#
#! End Listing Server Rsync Menu (Required line, do not delete).
#
# +----------------------------------------+
# |        Function f_check_version        |
# +----------------------------------------+
#
#     Rev: 2024-02-22
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - [OPTIONAL] File name to compare.
#          $3 - [OPTIONAL] to control display of messages and interactive user questions.
#                          null (default) - Display error and status messages and interactive user questions.
#                          1              - Display error messages only (Silent mode).
#          FILE_TO_COMPARE.
#    Uses: SERVER_DIR, MP_DIR, LOCAL_REPO_DIR, $FILE_TO_COMPARE, FILE_LIST,
#          VERSION, TEMP_FILE, ERROR.
# Outputs: ERROR.
#
# Summary: Check the version of a single, local file or script,
#          FILE_TO_COMPARE with the version of repository file.
#          If the repository file has latest version, then copy all
#          dependent files and libraries from the repository to local PC.
#
# TO DO enhancement: If local (LAN) repository is unavailable, then
#          connect to repository on the web if available.
#
# Dependencies: f_version_compare.
#
# PLEASE NOTE: RENAME THIS FUNCTION WITHOUT SUFFIX "_TEMPLATE" AND COPY
#              THIS FUNCTION INTO ANY SCRIPT WHICH DEPENDS ON THE
#              LIBRARY FILE "common_bash_function.lib".
#
f_check_version () {
      #
      #
      #=================================================================
      # EDIT THE LINES BELOW TO DEFINE THE LAN FILE SERVER DIRECTORY,
      # LOCAL MOUNTPOINT DIRECTORY, LOCAL REPOSITORY DIRECTORY AND
      # FILE TO COMPARE BETWEEN THE LOCAL PC AND (LAN) LOCAL REPOSITORY.
      #=================================================================
      #
      #
      # LAN File Server shared directory.
      # SERVER_DIR="[FILE_SERVER_DIRECTORY_NAME_GOES_HERE]"
      if [ -z "$SERVER_DIR" ] ; then
        SERVER_DIR="//file_server/files"
      fi
      #
      # Local PC mount-point directory.
      # MP_DIR="[LOCAL_MOUNT-POINT_DIRECTORY_NAME_GOES_HERE]"
      if [ -z "$MP_DIR" ] ; then
        MP_DIR="/mnt/file_server/files"
      fi
      #
      # Local PC mount-point with LAN File Server Local Repository full directory path.
      # Example:
      #                   File server shared directory is "//file_server/public".
      # Repository directory under the shared directory is "scripts/BASH/Repository".
      #                 Local PC Mount-point directory is "/mnt/file_server/public".
      #
      # Local PC mount-point with LAN File Server Local Repository full directory path.
      # LOCAL_REPO_DIR="$MP_DIR/[DIRECTORY_PATH_TO_LOCAL_REPOSITORY]"
      if [ -z "$LOCAL_REPO_DIR" ] ; then
        LOCAL_REPO_DIR="$MP_DIR/Local_Repository"
      fi
      #
      # Local PC file to be compared.
      if [ $# -eq 2 ] ; then
         # There are 2 arguments that have been passed to this function.
         # $2 contains the file name to compare.
         FILE_TO_COMPARE=$2
      else
         # $2 is null, so specify file name.
         if [ -z "$FILE_TO_COMPARE" ] ; then
            # FILE_TO_COMPARE is undefined so specify file name.
            FILE_TO_COMPARE=$(basename $0)
         fi
      fi
      #
      # Version of Local PC file to be compared.
      VERSION=$(grep --max-count=1 "VERSION" $FILE_TO_COMPARE)
      #
      # Initialize variables.
      FILE_LIST=$THIS_DIR/$THIS_FILE"_file_temp.txt"
      ERROR=0
      #
      # Delete any existing file.
      # This assures that FILE_LIST is not appended to but is newly created
      # in the code below. Added because typo may occur when using redirection
      # where typo ">>" is used instead of ">" at FILE NAME1.
      # i.e. typo at echo "[ FILE NAME1 GOES HERE ]"  >> $FILE_LIST
      if [ -e $FILE_LIST ] ; then
         rm $FILE_LIST
      fi
      #
      #
      #=================================================================
      # EDIT THE LINES BELOW TO SPECIFY THE FILE NAMES TO UPDATE.
      # FILE NAMES INCLUDE ALL DEPENDENT SCRIPTS AND LIBRARIES.
      #=================================================================
      #
      #
      # Create list of files to update and write to temporary file, FILE_LIST.
      #
      echo "server_rsync.sh"           > $FILE_LIST  # <<<--- INSERT ACTUAL FILE NAME HERE.
      echo "server_rsync.lib"         >> $FILE_LIST  # <<<--- INSERT ACTUAL FILE NAME HERE.
      echo "common_bash_function.lib" >> $FILE_LIST  # <<<--- INSERT ACTUAL FILE NAME HERE.
      #
      f_version_compare $1 $SERVER_DIR $MP_DIR $LOCAL_REPO_DIR $FILE_TO_COMPARE "$VERSION" $FILE_LIST
      #
      if [ -r  $FILE_LIST ] ; then
         rm  $FILE_LIST
      fi
      #
      unset FILE_LIST
      #
}  # End of function f_check_version.
#
# +----------------------------------------+
# |              Function f_any            |
# +----------------------------------------+
#
#  Inputs: $1 - "text", "dialog" or "whiptail" The CLI GUI application in use.
#    Uses: TFSTAMP
# Outputs: SOURCE_DIR, TARGET_DIR, SOURCE_DIR_STR_NAME, TARGET_DIR_STR_NAME, TARGET_FILESYSTEM, LOG_FILE.
#
# Summary: Select Source and Target directories. Create log file name.
#
# Dependencies: f_any_select f_go_nogo_rsync.
#
f_any () {
      #
      # Source directory name does not end with a forward-slash (/).
      # Target directory name must end in forward-slash (/).
      #
      # This script allows for a single one-way rsync back-up.
      #
      #
      # Diagram of Source and Back-up directory trees below:
      #
      #   Source Directory           Back-up Directory
      #
      #   /home/[sharename]          /parent-dir/server_rsync
      #      |--file01                  +--/[hostname of source server]
      #      |--file02                      +--/[sharename]
      #      +--file03                          |--rsync_server_FROM_PC_[ PC_SOURCE ]_SHARE-POINT_[ SOURCE_DIR ]_TIMESTAMP_[ DATE-TIME ].log
      #                                         |--file01
      #                                         |--file02
      #                                         +--file03
      #
      # Select SOURCE_DIR.
      f_any_select $1 "Source"
      ERROR=$?
      #
      if [ "$ERROR" -eq 0 ] && [ -n "$SOURCE_DIR" ] ; then
         # Explore TARGET_DIR to find last server_rsync log file
         # so that you may over-write the oldest TARGET_DIR backup.
         f_fzf $1
         #
         # Select TARGET_DIR.
         f_any_select $1 "Target"
         #
         case $TARGET_DIR in
              $SOURCE_DIR)
                 f_message $1 "OK" "Invalid Target directory" "Target directory is the same as the Source directory, returning to MAIN menu."
              ;;
              *)
                 # Add detection of filesystem of TARGET directory and set variable TARGET_FILESYSTEM accordingly.
                 # Or create either string input or menu choice for user to manually indicate the filesystem.
                 # This code will detect the filesystem of mounted devices.
                 # "lsblk --list --output name,fstype,mountpoint"
                 #
                 # TARGET_FILESYSTEM is the file system of the backup media (i.e. linux, FAT, NTFS),
                 # used to determine the best rsync options for that file system.
                 #
                 # Find the filesystem used by the TARGET_DIR.
                 TARGET_FILESYSTEM=$(findmnt --noheadings --target $TARGET_DIR | awk '{ print $3 }')
                 #
                 # Create SOURCE_DIR_STR_NAME; Get source directory and substitute "_" for "/".
                 SOURCE_DIR_STR_NAME=$(echo $SOURCE_DIR | sed -e 's|/|_|g' -e 's|_$||g')
                 #
                 # SOURCE_DIR_STR_NAME now begins with an underscore.
                 #
                 # Create TARGET_DIR_STR_NAME; Get source directory and substitute "_" for "/" and precede with "_".
                 TARGET_DIR_STR_NAME=$(echo $TARGET_DIR | sed -e 's|/|_|g' -e 's|_$||g')
                 #
                 # TARGET_DIR_STR_NAME now now begins with an underscore
                 #
                 # Create time stamp for Log File name.
                 TFSTAMP=$(date --date=now +"%Y-%m-%d_%H%M.%S")
                 #
                 # Specify the log file name.
                 #                      rsync_server_FROM_PC_[ PC_SOURCE ]_SHARE-POINT_[ SOURCE_DIR ]_TIMESTAMP_[ DATE-TIME ].log
                 SERVER_RSYNC_LOG_FILE="rsync_server_FROM_PC_"$SOURCE_SERVER_NAME"_SHARE-POINT"$SOURCE_DIR_STR_NAME"_TIMESTAMP_$TFSTAMP.log"
                 #
                 # Proceed with rsync procedure.
                 f_go_nogo_rsync $1 "$SOURCE_DIR" "$TARGET_DIR" "$SERVER_RSYNC_LOG_FILE" "$SOURCE_SERVER_NAME" "$TARGET_SERVER_NAME"
                 #
                 unset TFSTAMP
                 ;;
         esac
      #else
         # Error selecting Source Directory.
         # If [ $ERROR -ne 0 ] then an error message is displayed by f_any_select -> f_source_target_selected -> f_select_dir.
         # So no need for another error message here.
      fi
      #
} # End of function f_any
#
# +----------------------------------------+
# |          Function f_any_select         |
# +----------------------------------------+
#
#  Inputs: $1 - "text", "dialog" or "whiptail" The CLI GUI application in use.
#          $2 - "Source", "Target".
#    Uses: X, Y.
# Outputs: ERROR, LOCAL_SERVER_NAME,
#          SOURCE_DIR, SOURCE_SERVER_NAME,
#          TARGET_DIR, TARGET_SERVER_NAME.
#
# Summary: Select Source/Target directory using a dynamic menu of mounted
#          devices that changes according to the devices mounted on PC at
#          mount-points "/mnt" and "/media" directories.
#
# Dependencies: None.
#
f_any_select () {
      #
      # Create Source/Target Directory Menu which is a dynamic menu of mounted
      # devices that changes according to the devices mounted on PC at
      # mount-points "/mnt" and "/media" directories.
      #
      TEMP_FILE=$THIS_DIR/$THIS_FILE"_temp.txt"
      #
      ERROR=0
      # Get /mnt/ file server mount-points
      # Delete the forward-slashes in the first column of the  menu items using "Sed" to make the menu look better.
      df --all --human-readable | grep -e /mnt/ -e /media | awk '{ printf "%-28s %s\n", $6,$1 }' | sed -e 's|^/||g' > $TEMP_FILE"_directory_menu.txt"
      #
      # Set DIRSEL to "Source" or "Target" used only for the "awk" statement.
      DIRSEL=$2
      #
      # Insert field marker "#@@" that the menu will use to format data.
      # When a menu item is selected, run function f_source_target_selected^$GUI^<selected menu item>
      awk '{ print "#@@"$1"#@@"$2"#@@f_source_target_selected^$GUI^$DIRSEL^"$1 }' $TEMP_FILE"_directory_menu.txt" > $TEMP_FILE"_directory_menu2.txt"
      #
      # Put double-quotes around the 2nd phrase delimited by "#@@" which contains the mount point directory.
      # The forward-slashes (/) in the directory may mess up the creation of the data array for the menu by f_menu_arrays.
      sed -i -e 's|#@@|&"|2' -e 's|#@@|"&|3' $TEMP_FILE"_directory_menu2.txt"
      #
      # Save output file to temp file.
      mv $TEMP_FILE"_directory_menu2.txt" $TEMP_FILE"_directory_menu.txt"
      #
      # Insert the first menu option at the first line.
      sed -i '1i #@@Exit#@@Return to previous menu.#@@break' $TEMP_FILE"_directory_menu.txt"
      #
      # Insert required header and footer in $TEMP_FILE"_directory_menu.txt".
      sed -i '1i #' $TEMP_FILE"_directory_menu.txt"
      sed -i '1i #! +--------------------------------------------------------------+' $TEMP_FILE"_directory_menu.txt"
      sed -i '1i #! |               (Required header, do not delete).              |' $TEMP_FILE"_directory_menu.txt"
      #
      if [ "$2" = "Source" ] ; then
         sed -i '1i #! | Start Listing Source Directory Menu                              |' $TEMP_FILE"_directory_menu.txt"
      else
         sed -i '1i #! | Start Listing Target Directory Menu                              |' $TEMP_FILE"_directory_menu.txt"
      fi
      #
      echo "#" >> $TEMP_FILE"_directory_menu.txt"
      #
      if [ "$2" = "Source" ] ; then
         echo "#! | End Listing Source Directory Menu" >> $TEMP_FILE"_directory_menu.txt"
      else
         echo "#! | End Listing Target Directory Menu" >> $TEMP_FILE"_directory_menu.txt"
      fi
      #
      GENERATED_FILE=$THIS_DIR/$THIS_FILE"_directory_menu_generated.lib"
      #
      # Create generated menu script from array data.
      #
      # Note: ***If Sub-Menu title contains spaces,
      #       ***the size of the menu window will be too narrow.
      #
      # Menu title MUST substitute underscores for spaces.
      MENU_TITLE="$2_Directory_Menu"
      #
      #
      #==================================================================
      # EDIT THE LINE BELOW TO DEFINE $ARRAY_FILE AS THE ACTUAL FILE NAME
      # (LIBRARY) WHERE THE MENU ITEM DATA IS LOCATED.
      # THE LINES OF DATA ARE PREFIXED BY "#@@".
      #==================================================================
      #
      #
      # Specify library file name with menu item data.
      #ARRAY_FILE=$TEMP_FILE"_device_menu.txt"
      ARRAY_FILE=$TEMP_FILE"_directory_menu.txt"
      #
      # Create arrays from data.
      f_menu_arrays $ARRAY_FILE
      #
      f_menu_main_all_menus $1 "$MENU_TITLE" $TEMP_FILE"_directory_menu.txt"
      #
      # Was a local device to mount selected?
      if [ -z "$ANS" ] ; then
         # No, exit this function
         f_message $1 "NOK" "Directory Selection Error" "No directory specified."
         return 1
      fi
      #
      # The generated menu above, "$2_Directory_Menu" runs f_source_target_selected
      # Which outputs ANS (the directory path), SOURCE/TARGET_SERVER_NAME,SOURCE/TARGET_DIR.
      LOCAL_DIR=$ANS
      #
      LOCAL_SERVER_NAME=$(cat /etc/hostname)
      #
      TEMP_FILE=$THIS_DIR/$THIS_FILE"_temp.txt"
      #
      if [ -r $GENERATED_FILE ] ; then
         rm $GENERATED_FILE
      fi
      #
      if [ -r $ARRAY_FILE ] ; then
         rm $ARRAY_FILE
      fi
      #
      # Delete temporary file.
      if [ -e $TEMP_FILE ] ; then
         rm $TEMP_FILE
      fi
      #
      # Delete temporary file.
      if [ -e $TEMP_FILE"_directory_menu.txt" ] ; then
         rm $TEMP_FILE"_directory_menu.txt"
      fi
      #
      # Delete temporary file.
      if [ -e $THIS_DIR/$THIS_FILE"_menu_local_storage_generated.lib" ] ; then
         rm $THIS_DIR/$THIS_FILE"_menu_local_storage_generated.lib"
      fi
      #
      # Delete temporary file.
      if [ -e $THIS_DIR/$THIS_FILE"_menu_local_storage_temp.txt" ] ; then
         rm $THIS_DIR/$THIS_FILE"_menu_local_storage_temp.txt"
      fi
      #
} # End of function f_any_select.
#
# +----------------------------------------+
# |             Function f_fzf             |
# +----------------------------------------+
#
#  Inputs: $1 - "text", "dialog" or "whiptail" The CLI GUI application in use.
#    Uses: None.
# Outputs: None.
#
# Summary: Use application fzf to find the oldest rsync log file which has
#          the date of the backup in the file name. Then you can take note
#          of the mount-point and select it as the TARGET_DIR so that the
#          oldest backup is over-written by the current backup.
#
# Dependencies: fzf.
#
f_fzf () {
      #
      type fzf >/dev/null 2>&1
      ERROR=$?
      #
      # Is "fzf" installed?
      if [ $ERROR -eq 0 ] ; then
         # Yes, "fzf" is installed.
         #
         # fzf EXIT STATUS
         #       0      Normal exit
         #       1      No match
         #       2      Error
         #       130    Interrupted with CTRL-C or ESC
         #
         f_message text "OK" "Search for oldest server_rsync log file" "Find the oldest server_rsync log file and take note of the USB device (sda, sdb, sdc, or sdd).\n\nUse that USB 'sd' device as the TARGET_DIR in the 'Target Directory Menu'."
         # Blank the screen.
         clear
         #
         # Log File format:
         # rsync_server_FROM_[ PC_SOURCE ]_[ SOURCE_DIR ]_TIMESTAMP_[ DATE-TIME ].log
         fzf --no-multi --query=^rsync_server_FROM_scotty --preview 'less {}'
      else
         # No, "fzf" is not installed.
         f_message $1 "OK" "Search for oldest server_rsync log file" "Check to see which mount-point has the oldest log file"
         f_file_manager $1 /media/ 2
      fi
         #
} # End of function f_fzf.
         #
# +----------------------------------------+
# |   Function f_source_target_selected    |
# +----------------------------------------+
#
#  Inputs: $1 - "text", "dialog" or "whiptail" The CLI GUI application in use.
#          $2 - "Source" or "Target".
#          $3 - Menu choice data.
#    Uses: None.
# Outputs: ANS,
#          SOURCE_DIR, SOURCE_SERVER_NAME,
#          TARGET_DIR, TARGET_SERVER_NAME.
#
# Summary: When a directory is chosen from the  "Storage Device Menu",
#          this function is run to acknowledge the menu item chosen and
#          to set the chosen menu item to $ANS.
#
# Dependencies: f_any_select.
#
f_source_target_selected () {
      #
      ERROR=0
      #
      # Directory name has "~" in path to prevent f_menu_arrays and f_create_show_menu called by f_any_select
      # from being messed up with the "/" forward slashes in the directory name.
      #
      # Now that the directory has been chosen from the "Storage Device Menu,
      # restore the true directory name.
      #
      # Substitute "/" for "~" to restore true directory name.
      # Output directory name, set $ANS to directory name string.
      ANS="/"$(echo $3 | sed 's|~|/|g')
      case $2 in
           Source)
              f_select_dir $1 "$2 Directory" "$ANS" 1
              #
              # Did the user try to Cancel or Esc?
              if [ $ERROR -eq 0 ] ; then
                 # No, proceed with rsync process.
                 # Set Source Directory.
                 SOURCE_DIR="$ANS"
                 #
                 # Set Source server name.
                 SOURCE_SERVER_NAME=$(findmnt --noheadings --target $SOURCE_DIR | awk '{ print $1 }' | awk -F "/" '{ print $3 }')
                 #
                 case $SOURCE_DIR in
                      */)
                          # Trailing slash is included and not missing.
                      ;;
                      *)
                          # Trailing slash is missing.
                          # Add trailing slash.
                          # Add trailing (/) slash if it is missing so that files within $SOURCE_DIR are rsynced.
                          # Otherwise the entire directory $SOURCE_DIR will be created as a sub-directory of $TARGET_DIR.
                          SOURCE_DIR=$(echo -n $SOURCE_DIR"/" )
                      ;;
                 esac
                 #
                 # Exit from Storage Source Device Menu
                 CHOICE="QUIT"
              else
                 # Yes, Cancel or Esc selected.
                 SOURCE_DIR=""
                 f_message $1 "NOK" "Returning to Previous Menu" "No directory selected, returning to $2 Directory Menu."
              fi
           ;;
           Target)
              f_select_dir $1 "Recipient $2 Directory" "$ANS" 1
              #
              # Did the user try to Cancel or Esc?
              if [ $ERROR -eq 0 ] ; then
                 # No, proceed with rsync process.
                 # Set Source Directory.
                 TARGET_DIR="$ANS"
                 #
                 # Set Target server name.
                 TARGET_SERVER_NAME=$(findmnt --noheadings --target $TARGET_DIR | awk '{ print $1 }' | awk -F "/" '{ print $3 }')
                 #
                 # Add trailing (/) slash if it is missing so that files within $TARGET_DIR are rsynced.
                 # Otherwise the entire directory $SOURCE_DIR will be created as a sub-directory of $TARGET_DIR.
                 case $TARGET_DIR in
                      */)
                          # Trailing slash is included and not missing.
                      ;;
                      *)
                          # Trailing slash is missing.
                          # Add trailing slash.
                          TARGET_DIR=$(echo -n $TARGET_DIR"/" )
                      ;;
                 esac
                 # Exit from Storage Target Device Menu
                 CHOICE="QUIT"
              else
                 # Yes, Cancel or Esc.
                 TARGET_DIR=""
                 f_message $1 "NOK" "Returning to Previous Menu" "No directory selected, returning to $2 Directory Menu."
              fi
           ;;
      esac
      #
} # End of function f_source_target_selected.
#
# +----------------------------------------+
# |      Function f_choose_source_dir      |
# +----------------------------------------+
#
#  Inputs: $1 - "text", "dialog" or "whiptail" The command-line user-interface in use.
#          $2 - SOURCE_DIR - Source directory.
#    Uses: None.
# Outputs: ERROR, SOURCE_DIR.
#
# Summary: Set SOURCE_DIR to user-entered directory names.
#
f_choose_source_dir () {
      #
      # Choose the Source Directory.
      f_select_dir $1 "Select Source Directory" "$2" 1
      #
      SOURCE_DIR=$ANS
      #
      # Did the user try to Cancel or Esc?
      if [ $ERROR -eq 0 ] ; then
         # No, proceed with rsync process.
         SOURCE_DIR=$ANS
      else
         SOURCE_DIR=""
      fi
      #
} # End of function f_choose_source_dir.
#
# +----------------------------------------+
# |      Function f_choose_target_dir      |
# +----------------------------------------+
#
#  Inputs: $1 - "text", "dialog" or "whiptail" The command-line user-interface in use.
#          $2 - TARGET_DIR - Target directory.
#    Uses: None.
# Outputs: ERROR, TARGET_DIR.
#
# Summary: Set TARGET_DIR to user-entered directory names.
#
f_choose_target_dir () {
      #
      # Choose the Target Directory.
      f_select_dir $1 "Select Target Directory" "$2" 1
      #
      # Did the user try to Cancel or Esc?
      if [ $ERROR -eq 0 ] ; then
         # No, proceed with rsync process.
         TARGET_DIR=$ANS
      else
         TARGET_DIR=""
      fi
      #
} # End of function f_choose_target_dir.
#
# +----------------------------------------+
# |           Function f_check_dirs        |
# +----------------------------------------+
#
#  Inputs: $1 - "text", "dialog" or "whiptail" The command-line user-interface in use.
#          $2 - SOURCE_DIR - Source directory.
#          $3 - TARGET_DIR - Target directory.
#    Uses: X.
# Outputs: ERROR.
#
# Summary: Check if the directories SOURCE_DIR and TARGET_DIR exist.
#
f_check_dirs () {
      #
      if [ -d $2 ] && [ -d $3 ] ; then
         # SOURCE_DIR and TARGET_DIR directories exist.
         ERROR=0
         # Check if TARGET_DIR is a sub-directory of the SOURCE_DIR
         # If it is, rsync will go into a recursive non-ending loop.
         case $3 in
              $2*)
                  # Invalid TARGET_DIR.
                  ERROR=1
                  #
                  echo "Target Directory is a sub-directory of the Source Directory." > $TEMP_FILE
                  echo >> $TEMP_FILE
                  echo "SOURCE_DIR=$SOURCE_DIR" >> $TEMP_FILE
                  echo >> $TEMP_FILE
                  echo "TARGET_DIR=$TARGET_DIR" >> $TEMP_FILE
                  echo >> $TEMP_FILE
                  echo "Choose another Target Directory." >> $TEMP_FILE
                  #
                  f_message $1 "OK" "Directory Error" $TEMP_FILE
                  #
                  # Choose the Target Directory.
                  f_choose_target_dir $1 $3
              ;;
         esac
      else
         # Directory missing.
         ERROR=1
         #
         if [ ! -d $2 ] ; then
            echo "Source Directory does not exist." > $TEMP_FILE
            echo >> $TEMP_FILE
            echo "$SOURCE_DIR" >> $TEMP_FILE
            echo  >> $TEMP_FILE
            echo "Server-Rsync backup aborted due to missing directory." >> $TEMP_FILE
            #
            f_message $1 "OK" "Directory Error" $TEMP_FILE
         fi
         #
         if [ ! -d $3 ] ; then
            echo "Target Directory does not exist." > $TEMP_FILE
            echo >> $TEMP_FILE
            echo "$TARGET_DIR" >> $TEMP_FILE
            echo  >> $TEMP_FILE
            echo "Server-Rsync backup aborted due to missing directory." >> $TEMP_FILE
            echo  >> $TEMP_FILE
            echo "Does the Back-up Directory need to be created?" >> $TEMP_FILE
            echo  >> $TEMP_FILE
            echo  >> $TEMP_FILE
            echo "You need to create a Back-up Directory with the format:" >> $TEMP_FILE
            echo  >> $TEMP_FILE
            echo "     /[mount-point]/server_rsync/[hostname of source server]/[sharename]"  >> $TEMP_FILE
            echo "i.e. /media/PC_Bob_backup/sda1/server_rsync/PC_Sam_source/public_files"  >> $TEMP_FILE
            echo  >> $TEMP_FILE
            echo "Press OK to display Source/Back-up directory trees" >> $TEMP_FILE
            #
            f_message $1 "OK" "Directory Error" $TEMP_FILE
            #
            f_help_directory_diagrams^$GUI
         fi
      fi
      #
} # End of function f_check_dirs.
#
# +----------------------------------------+
# |        Function f_go_nogo_rsync        |
# +----------------------------------------+
#
#  Inputs: $1 - "text", "dialog" or "whiptail" The CLI GUI application in use.
#          $2 - SOURCE_DIR Source directory.
#          $3 - TARGET_DIR Target directory.
#          $4 - Basename Log file of rsync command (without /var/log/rsync).
#          $5 - SOURCE_SERVER_NAME Name of Source file server.
#          $6 - TARGET_SERVER_NAME Name of Target file server.
#          ERROR.
#    Uses: ANS
# Outputs: None.
#
# Summary: Check requirements and parameters before rsync.
#
# Dependencies: f_message, f_abort, f_show_mount_points, f_yn_question, f_rsync.
#
f_go_nogo_rsync () {
      #
      # Does directory "/var/log/rsync" exist?
      if [ ! -d /var/log/rsync ] ; then
         f_message $1 "OK" "!!!WARNING!!!" "Cannot continue, /var/log/rsync directory either does not exist\nor you do not have WRITE permission\nto the  log directory below:\n\n /var/log/rsync"
         f_abort $1
      fi
      #
      # Do the SOURCE and TARGET directories exist?
      f_check_dirs $1 "$2" "$3"
      if [ $ERROR -eq 0 ] ; then
         # Yes, directories exists.
         f_go_nogo_rsync_2 "$1" "$2" "$3" "$4" "$5" "$6"
         #
      else
         f_message $1 "OK" "Failed Mount" "Cannot synchronize due to mounting problems.\nrsync is aborted."
      fi
      #
} # End of function f_go_nogo_rsync
#
# +----------------------------------------+
# |       Function f_go_nogo_rsync_2       |
# +----------------------------------------+
#
#  Inputs: $1 - "text", "dialog" or "whiptail" The CLI GUI application in use.
#          $2 - SOURCE_DIR Source directory.
#          $3 - TARGET_DIR Target directory.
#          $4 - Basename Log file of rsync command (without /var/log/rsync).
#          $5 - SOURCE_SERVER_NAME Name of Source file server.
#          $6 - TARGET_SERVER_NAME Name of Target file server.
#          ERROR.
#    Uses: ANS, DIR_SIZE.
# Outputs: None.
#
# Summary: Check requirements and parameters before rsync.
#
# Dependencies: f_message, f_abort, f_show_mount_points, f_yn_question, f_rsync.
#
f_go_nogo_rsync_2 () {
      #
      echo " Script: $THIS_FILE (version $VERSION)" > $TEMP_FILE
      echo >> $TEMP_FILE
      echo "From SOURCE directory:" >> $TEMP_FILE
      echo "$2" >> $TEMP_FILE
      echo >> $TEMP_FILE
      echo "To TARGET directory:" >> $TEMP_FILE
      echo "$3" >> $TEMP_FILE
      echo >> $TEMP_FILE
      echo "Log file:" >> $TEMP_FILE
      echo "$4" >> $TEMP_FILE
      echo >> $TEMP_FILE
      echo "Is this correct?" >> $TEMP_FILE
      echo "Next screen will confirm choice." >> $TEMP_FILE
      #
      f_message $1 "OK" "Summary Before Rsync Back-up" $TEMP_FILE
      #
      f_yn_question $1 "Y" "Confirmation of SOURCE/TARGET" "Proceed with Rsync backup?"
      #
      if [ $ANS -eq 0 ] ; then
         # Yes, use selected directories.
         #
         # Does source directory have contents? If it is not mounted, then it will be empty of contents.
         DIR_SIZE=$(ls --size "$2")
         if [ "$DIR_SIZE" = "total 0" ] ; then
            # No, abort and quit.
            f_message $1 "OK" "*** Abort rsync ***" "Source directory is empty. Aborting rsync operation."
         else
            # Yes, proceed with rsync.
            #
            # Proceed with rsync.
            f_rsync "$1" "$2" "$3" "$4" "$5" "$6"
         fi
         #
         unset DIR_SIZE
      else
         # No, bad selection. Null selections. Quit.
         f_message $1 "OK" "!!! Abort rsync !!!" "Aborting rsync operation."
      fi
      #
} # End of function f_go_nogo_rsync_2
#
# +------------------------------------+
# |           Function f_rsync         |
# +------------------------------------+
#
#  Inputs: $1 - "text", "dialog" or "whiptail" The CLI GUI application in use.
#          $2 - SOURCE_DIR Source directory.
#          $3 - TARGET_DIR Target directory.
#          $4 - Basename Log file of rsync command (without /var/log/rsync).
#          $5 - SOURCE_SERVER_NAME Name of Source file server.
#          $6 - TARGET_SERVER_NAME Name of Target file server.
#    Uses: None.
# Outputs: None.
#
# Summary: Check directory pre-requisites and ask final go/nogo question.
#
# Dependencies: f_message, f_show_mount_points, f_rsync2.
#
f_rsync () {
      #
      # For any mount point to synchronize:
      #
      # Prerequisites: External device share available on TARGET and
      #                directory /var/log/rsync exists.
      #
      # If you edit this shell script, use -n option or --dry-run for testing.
      #
      #  when SOURCE and/or TARGET mount-point does not exist.
      #
      if [ ! -d $2 ] || [ ! -d $3 ] ; then
         # Source and/or Target directories missing.
         if [ ! -d $2 ] ; then
            f_message $1 "OK" "!!!WARNING!!!" "Cannot continue, SOURCE directory either does not exist\nor you do not have WRITE permission\nto the SOURCE directory below:\n\n $2"
         else
            f_message $1 "OK" "!!!WARNING!!!" "Cannot continue, TARGET directory either does not exist\nor you do not have WRITE permission\nto the TARGET directory below:\n\n $3"
         fi
         #
         f_message $1 "OK" "Help Diagnose" "To help diagnose problem, here is a list of mounted drives/devices."
         #
         # List of mounted drives/devices.
         f_show_mount_points $1
         #
         f_message $1 "OK" "Restart Needed" "Re-start this script once the external device is mounted properly\nat the mount-point directory."
      else
         # Source and Target directories validated, use selected directories to rsync.
         f_rsync2 "$1" "$2" "$3" "$4" "$5" "$6"
      fi
      #
} # End of function f_rsync
#
# +------------------------------------+
# |           Function f_rsync2        |
# +------------------------------------+
#
#  Inputs: $1 - "text", "dialog" or "whiptail" The CLI GUI application in use.
#          $2 - SOURCE_DIR Source directory.
#          $3 - TARGET_DIR Target directory.
#          $4 - Basename Log file of rsync command (without /var/log/rsync).
#          $5 - SOURCE_SERVER_NAME Name of Source file server.
#          $6 - TARGET_SERVER_NAME Name of Target file server.
#    Uses: None.
# Outputs: None.
#
# Summary: Start actual rsync and create log file.
#
# Dependencies: f_test_connection, f_rsync_command, f_yn_question, f_log_display.
#
f_rsync2 () {
      #
      f_test_connection $1 $5
      #
      if [ $ERROR -eq 0 ] ; then
         f_test_connection $1 $6
         #
         if [ $ERROR -eq 0 ] ; then
            #
            # Blank the screen.
            clear
            #
            # Do the actual rsync.
            f_rsync_command "$1" "$2" "$3" "$4" "$5"
            ERROR=$?
            if [ $ERROR -ne 0 ] ; then
               return 1
            fi
            #
            f_log_format $1 "$4" "$START_TIME" "$END_TIME" "$2" "$3"
            #
            # 2024-06-16 Comment out code to copy log file to Source Directory.
            #            I decided not to have a bunch of log files clogging up the $SOURCE_DIR.
            # Is the SOURCE_DIR the different from the directory which log file exists (where rsync_snapshot_backup.sh exists)?
            #if [ "$THIS_DIR" != "$2" ] ; then
            #   # Yes, SOURCE_DIR is different from directory of log file, so copy to SOURCE_DIR.
            #   sudo cp $4 $2
            #fi
            #
            # Copy $LOG_FILE into $TARGET directory.
            sudo cp $4 $3
            #
            # Copy log file (on backup media) to localhost's /var/log/rsync directory.
            sudo cp $4 /var/log/rsync
            #
            # Move log file to TEMP_FILE then f_message will delete TEMP_FILE.
            mv $4 $TEMP_FILE
            f_log_display $1 $TEMP_FILE
         fi
      fi
      #
} # End of function f_rsync2
#
# +------------------------------------+
# |      Function f_rsync_command      |
# +------------------------------------+
#
#  Inputs: $1 - "text", "dialog" or "whiptail" The CLI GUI application in use.
#          $2 - SOURCE Source directory.
#          $3 - TARGET Target directory.
#          $4 - Basename Log file of rsync command (without /var/log/rsync).
#          TARGET_FILESYSTEM, THIS_FILE, VERSION.
#    Uses: TIME_FILE.
# Outputs: START_TIME, END_TIME.
#
# Summary: Do rsync file synchronization.
#
# Dependencies: None.
#
f_rsync_command () {
      #
      # Record the Start date/time of the rsync backup.
      START_TIME=$(date  +"%A %B %d, %Y -- %T")
      #
      case $TARGET_FILESYSTEM in
           linux | ext2 | ext3 | ext4)
              # If backing up to ext2-ext4 partition, you can preserve permissions, owner, group. Therefore can use -a(rchive) option
              # which also backs up --devices --specials which are irrelevant for this user data.
              # So you could use options -avhi (archive, verbose, human-readable, itemize changes).
              #
              # DO create or follow symlinks nor preserve permissions. --links (Personal choice).
              #
              # Personal preference is not to use --archive but to specify each option separately.
              #
              # Are all the required parameters entered?
              if [ -n "$4" ] && [ -n "$2" ] && [ -n "$3" ] ; then
                 # Yes, confirm rsync command.
                 f_ask_question $1 "Rsync Command" "Enter rsync command (insert '--dry-run' for a trial run)" "sudo rsync --recursive --verbose --itemize-changes --human-readable --size-only --progress --delete --links --times --perms --group --owner --exclude '.gvfs' --log-file=/var/log/rsync/$4 $2 $3"
              else
                 f_message $1 "OK" "Required Parameters Missing" "Rsync parameters [ SOURCE_DIR ], [ TARGET_DIR ] or [ LOG-FILE ] missing.\nCannot continue with Rsync."
              fi
           ;;
           fat | fat32 | vfat | ntfs | *)
              # # Prevents rsync from copying linux hard links and linux permissions, owner, group properties when copying from a linux file server.
              # If backing up to a Microsoft filesystem partition or any other filesystems, DO NOT preserve permissions, owner, group. Therefore cannot use -a(rchive) option.
              # Use options -rltDvhi (recursive, links (symlinks), times, Devices/specials, verbose, human-readable, itemize changes.
              #
              # DO NOT create or follow symlinks nor preserve permissions. (Personal choice).
              # sudo rsync --recursive --times --devices --verbose --human-readable --size-only --progress --delete --exclude '.gvfs' --log-file=$5 $2 $3
              #
              # Are all the required parameters entered?
              if [ -n "$4" ] && [ -n "$2" ] && [ -n "$3" ] ; then
                 # Yes, confirm rsync command.
                 f_ask_question $1 "Rsync Command" "Enter rsync command (insert '--dry-run' for a trial run)" "sudo rsync --recursive --times --devices --verbose --human-readable --size-only --progress --delete --exclude '.gvfs' --log-file=/var/log/rsync/$4 $2 $3"
              else
                 f_message $1 "OK" "Required Parameters Missing" "Rsync parameters [ SOURCE_DIR ], [ TARGET_DIR ] or [ LOG-FILE ] missing.\nCannot continue with Rsync."
              fi
           ;;
      esac
      #
      if [ -n "$ANS" ] ; then
         # Blank the screen.
         clear
         #
         # Run the rsync command as specified in the $ANS string.
         eval $ANS
         ERROR=$?
         if [ $ERROR -ne 0 ] ; then
            f_message $1 "OK" "Rsync Error" "The rsync command failed.\nCommand: $ANS"
         fi
         #
         # Record the End date/time of the rsync backup.
         END_TIME=$(date  +"%A %B %d, %Y -- %T")
         #
         # Blank the screen.
         clear
      else
         f_message $1 "OK" "Rsync command error" "Rsync command was not entered properly in text box."
         return 1
      fi
      #
      #
      # Selected optional parameters from the Manpages "man rsync"
      #
      # --archive, -a
      #     This is equivalent to -rlptgoD.  It is a quick way of saying you want recursion and want to pre‐
      #     serve almost everything.  Be aware that it does not include preserving ACLs (-A),  xattrs  (-X),
      #     atimes (-U), crtimes (-N), nor the finding and preserving of hardlinks (-H).
      #
      #     The  only exception to the above equivalence is when --files-from is specified, in which case -r
      #     is not implied.
      #
      #--compress, -z
      #     With  this  option,  rsync compresses the file data as it is sent to the destination ma‐
      #     chine, which reduces the amount of data being transmitted -- something  that  is  useful
      #     over a slow connection.
      #
      #     Rsync supports multiple compression methods and will choose one for you unless you force
      #     the choice using the --compress-choice (--zc) option.
      #
      #     Run rsync --version to see the default compress list compiled into your version.
      #
      #     When both sides of the transfer are at least 3.2.0, rsync chooses the first algorithm in
      #     the client's list of choices that is also in the server's list of choices.  If no common
      #     compress choice is found, rsync exits with an error.  If the remote rsync is too old  to
      #     support checksum negotiation, its list is assumed to be "zlib".
      #
      #     The  default  order  can  be  customized  by setting the environment variable RSYNC_COM‐
      #     PRESS_LIST to a space-separated list of acceptable compression  names.   If  the  string
      #     contains a "&" character, it is separated into the "client string & server string", oth‐
      #     erwise the same string applies to both.  If the string (or string portion)  contains  no
      #     non-whitespace  characters,  the default compress list is used.  Any unknown compression
      #     names are discarded from the list, but a list with  only  invalid  names  results  in  a
      #     failed negotiation.
      #
      #     There  are  some older rsync versions that were configured to reject a -z option and re‐
      #     quire the use of -zz because their compression library was not compatible with  the  de‐
      #     fault  zlib  compression method.  You can usually ignore this weirdness unless the rsync
      #     server complains and tells you to specify -zz.
      #
      #     See also the --skip-compress option for the default list of file suffixes that  will  be
      #     transferred with no (or minimal) compression.
      #
      # --compress-choice=STR, --zc=STR
      #     This  option  can be used to override the automatic negotiation of the compression algo‐
      #     rithm that occurs when --compress is used.  The option implies --compress unless  "none"
      #     was specified, which instead implies --no-compress.
      #
      #     The compression options that you may be able to use are:
      #
      #     o      zstd
      #
      #     o      lz4
      #
      #     o      zlibx
      #
      #     o      zlib
      #
      #     o      none
      #
      #     Run  rsync --version  to see the default compress list compiled into your version (which
      #     may differ from the list above).
      #
      #     Note that if you see an error about an option named  --old-compress  or  --new-compress,
      #     this  is  rsync trying to send the --compress-choice=zlib or --compress-choice=zlibx op‐
      #     tion in a backward-compatible manner that more rsync versions  understand.   This  error
      #     indicates  that  the  older  rsync version on the server will not allow you to force the
      #     compression type.
      #
      # Note that the "zlibx" compression algorithm is just the "zlib"  algorithm  with  matched
      #     data excluded from the compression stream (to try to make it more compatible with an ex‐
      #     ternal zlib implementation).
      #
      # --copy-links, -L
      #     When symlinks are encountered, the item that they point to  (the  referent)  is  copied,
      #     rather  than the symlink.  In older versions of rsync, this option also had the side-ef‐
      #     fect of telling the receiving side to follow symlinks, such as symlinks to  directories.
      #     In  a  modern rsync such as this one, you'll need to specify --keep-dirlinks (-K) to get
      #     this extra behavior.  The only exception is when sending files to an rsync that  is  too
      #     old  to  understand -K -- in that case, the -L option will still have the side-effect of
      #     -K on that older receiving rsync.
      #
      # --delete
      #     This tells rsync to delete extraneous files from the receiving side (ones that aren't on
      #     the  sending  side), but only for the directories that are being synchronized.  You must
      #     have asked rsync to send the whole directory (e.g. "dir"  or  "dir/")  without  using  a
      #     wildcard  for  the directory's contents (e.g. "dir/*") since the wildcard is expanded by
      #     the shell and rsync thus gets a request to transfer individual  files,  not  the  files'
      #     parent  directory.  Files that are excluded from the transfer are also excluded from be‐
      #     ing deleted unless you use the --delete-excluded option or mark the rules as only match‐
      #     ing on the sending side (see the include/exclude modifiers in the FILTER RULES section).
      #
      #     Prior  to  rsync 2.6.7, this option would have no effect unless --recursive was enabled.
      #     Beginning with 2.6.7, deletions will also occur when --dirs (-d) is  enabled,  but  only
      #     for directories whose contents are being copied.
      #
      #     This  option can be dangerous if used incorrectly! It is a very good idea to first try a
      #     run using the --dry-run option (-n) to see what files are going to be deleted.
      #
      #     If the sending side detects any I/O errors, then the deletion of any files at the desti‐
      #     nation will be automatically disabled.  This is to prevent temporary filesystem failures
      #     (such as NFS errors) on the sending side from causing a massive deletion of files on the
      #     destination.  You can override this with the --ignore-errors option.
      #
      #     The  --delete  option may be combined with one of the --delete-WHEN options without con‐
      #     flict, as well as --delete-excluded.  However, if none of the --delete-WHEN options  are
      #     specified,  rsync  will choose the --delete-during algorithm when talking to rsync 3.0.0
      #     or newer, and the --delete-before algorithm when talking to an older  rsync.   See  also
      #     --delete-delay and --delete-after.
      #
      # --devices
      #     This option causes rsync to transfer character and block device files to the remote sys‐
      #     tem to recreate these devices.  This option has no effect if the receiving rsync is  not
      #     run as the super-user (see also the --super and --fake-super options).
      #
      # --specials
      #     This option causes rsync to transfer special files such as named sockets and fifos.
      #
      # -D  The -D option is equivalent to --devices --specials.
      #
      # --dry-run, -n
      #     This  makes rsync perform a trial run that doesn't make any changes (and produces mostly
      #     the same output as a real run).  It is most commonly used in combination with the --ver‐
      #     bose,  -v  and/or --itemize-changes, -i options to see what an rsync command is going to
      #     do before one actually runs it.
      #
      #     The output of --itemize-changes is supposed to be exactly the same on a dry  run  and  a
      #     subsequent  real  run  (barring  intentional  trickery  and system call failures); if it
      #     isn't, that's a bug.  Other output should be mostly unchanged, but may  differ  in  some
      #     areas.   Notably,  a  dry  run  does  not  send  the  actual data for file transfers, so
      #     --progress has no effect, the  "bytes  sent",  "bytes  received",  "literal  data",  and
      #     "matched  data" statistics are too small, and the "speedup" value is equivalent to a run
      #     where no file transfers were needed.
      #
      # --exclude=PATTERN
      #     This option is a simplified form of the --filter option that defaults to an exclude rule
      #     and does not allow the full rule-parsing syntax of normal filter rules.
      #
      #     See the FILTER RULES section for detailed information on this option.
      #
      # --force
      #     This  option  tells rsync to delete a non-empty directory when it is to be replaced by a
      #     non-directory.  This is only relevant if deletions are not active (see --delete for  de‐
      #     tails).
      #
      #     Note for older rsync versions: --force used to still be required when using --delete-af‐
      #     ter, and it used to be non-functional unless the --recursive option was also enabled.
      #
      # --human-readable, -h
      #     Output numbers in a more human-readable format.  There are 3 possible levels: (1) output
      #     numbers with a separator between each set of 3 digits (either a comma or a  period,  de‐
      #     pending  on if the decimal point is represented by a period or a comma); (2) output num‐
      #     bers in units of 1000 (with a character suffix for larger units -- see below); (3)  out‐
      #     put numbers in units of 1024.
      #
      #     The  default is human-readable level 1.  Each -h option increases the level by one.  You
      #     can take the level down to 0 (to output numbers as pure digits) by specifying the  --no-
      #     human-readable (--no-h) option.
      #
      #     The  unit letters that are appended in levels 2 and 3 are: K (kilo), M (mega), G (giga),
      #     T (tera), or P (peta).  For example, a  1234567-byte  file  would  output  as  1.23M  in
      #     level-2 (assuming that a period is your local decimal point).
      #
      #     Backward compatibility note: versions of rsync prior to 3.1.0 do not support human-read‐
      #     able level 1, and they default to level 0.  Thus, specifying one or two -h options  will
      #     behave  in  a  comparable manner in old and new versions as long as you didn't specify a
      #     --no-h option prior to one or more -h options.  See the --list-only option for one  dif‐
      #     ference.
      #
      # --itemize-changes, -i
      #     Requests a simple itemized list of the changes that are being made to each file, includ‐
      #     ing  attribute  changes.  This is exactly the same as specifying --out-format='%i %n%L'.
      #     If you repeat the option, unchanged files will also be output, but only if the receiving
      #     rsync  is at least version 2.6.7 (you can use -vv with older versions of rsync, but that
      #     also turns on the output of other verbose messages).
      #
      #     The "%i" escape has a cryptic output that is 11 letters long.   The  general  format  is
      #     like  the string YXcstpoguax, where Y is replaced by the type of update being done, X is
      #     replaced by the file-type, and the other letters represent attributes that may be output
      #     if they are being modified.
      #
      # --links, -l
      #     When symlinks are encountered, recreate the symlink on the destination.
      #
      # --log-file=FILE
      #     This option causes rsync to log what it is doing to a file.  This is similar to the log‐
      #     ging that a daemon does, but can be requested for the client side and/or the server side
      #     of a non-daemon transfer.  If specified as a client option, transfer logging will be en‐
      #     abled  with a default format of "%i %n%L".  See the --log-file-format option if you wish
      #     to override this.
      #
      #     Here's a example command that requests the remote side to log what is happening:
      #
      #         rsync -av --remote-option=--log-file=/tmp/rlog src/ dest/
      #
      #     This is very useful if you need to debug why a connection is closing unexpectedly.
      #
      # --progress
      #     This option tells rsync to print information showing the progress of the transfer.  This
      #     gives a bored user something to watch.  With a modern rsync this is the same as specify‐
      #     ing  --info=flist2,name,progress,  but  any  user-supplied settings for those info flags
      #     takes precedence (e.g.  "--info=flist0 --progress").
      #
      #     While rsync is transferring a regular file, it updates a progress line that  looks  like
      #     this:
      #
      #         782448  63%  110.64kB/s    0:00:04
      #
      #     In  this  example,  the  receiver  has reconstructed 782448 bytes or 63% of the sender's
      #     file, which is being reconstructed at a rate of 110.64 kilobytes  per  second,  and  the
      #     transfer will finish in 4 seconds if the current rate is maintained until the end.
      #
      #     These  statistics  can be misleading if rsync's delta-transfer algorithm is in use.  For
      #     example, if the sender's file consists of the basis file followed  by  additional  data,
      #     the  reported rate will probably drop dramatically when the receiver gets to the literal
      #     data, and the transfer will probably take much longer to finish than the receiver  esti‐
      #     mated as it was finishing the matched part of the file.
      #
      #     When  the  file  transfer finishes, rsync replaces the progress line with a summary line
      #     that looks like this:
      #
      #         1,238,099 100%  146.38kB/s    0:00:08  (xfr#5, to-chk=169/396)
      #
      #     In this example, the file was 1,238,099 bytes long in total, the average rate of  trans‐
      #     fer  for  the whole file was 146.38 kilobytes per second over the 8 seconds that it took
      #     to complete, it was the 5th transfer of a regular file during the current rsync session,
      #     and there are 169 more files for the receiver to check (to see if they are up-to-date or
      #     not) remaining out of the 396 total files in the file-list.
      #
      #     In an incremental recursion scan, rsync won't know the total  number  of  files  in  the
      #     file-list  until  it reaches the ends of the scan, but since it starts to transfer files
      #     during the scan, it will display a line with the text "ir-chk" (for  incremental  recur‐
      #     sion check) instead of "to-chk" until the point that it knows the full size of the list,
      #     at which point it will switch to using "to-chk".  Thus, seeing "ir-chk"  lets  you  know
      #     that the total count of files in the file list is still going to increase (and each time
      #     it does, the count of files left to check will increase by the number of the files added
      #     to the list).
      #
      # --recursive, -r
      #     This tells rsync to copy directories recursively.  See also --dirs (-d).
      #
      #     Beginning with rsync 3.0.0, the recursive algorithm used is now an incremental  scan  that  uses
      #     much  less memory than before and begins the transfer after the scanning of the first few direc‐
      #     tories have been completed.  This incremental scan only affects  our  recursion  algorithm,  and
      #     does not change a non-recursive transfer.  It is also only possible when both ends of the trans‐
      #     fer are at least version 3.0.0.
      #
      #     Some options require rsync to know the full file list, so these options disable the  incremental
      #     recursion  mode.   These include: --delete-before, --delete-after, --prune-empty-dirs, and --de‐
      #     lay-updates.  Because of this, the  default  delete  mode  when  you  specify  --delete  is  now
      #     --delete-during  when both ends of the connection are at least 3.0.0 (use --del or --delete-dur‐
      #     ing to request this improved deletion mode explicitly).  See also the --delete-delay option that
      #     is a better choice than using --delete-after.
      #
      #     Incremental recursion can be disabled using the --no-inc-recursive option or its shorter --no-i-
      #     r alias.
      #
      # --size-only
      #     This  modifies  rsync's "quick check" algorithm for finding files that need to be trans‐
      #     ferred, changing it from the default of transferring files with either a changed size or
      #     a  changed last-modified time to just looking for files that have changed in size.  This
      #     is useful when starting to use rsync after using another mirroring system which may  not
      #     preserve timestamps exactly.
      #
      # --times, -t
      #     This  tells rsync to transfer modification times along with the files and update them on
      #     the remote system.  Note that if this option is not used, the optimization that excludes
      #     files  that  have not been modified cannot be effective; in other words, a missing -t or
      #     -a will cause the next transfer to behave as if it used -I, causing all files to be  up‐
      #     dated  (though rsync's delta-transfer algorithm will make the update fairly efficient if
      #     the files haven't actually changed, you're much better off using -t).
      #
      # --perms, -p
      #     preserve permissions
      #
      # --group, -g
      #     preserve group
      #
      # --owner, -o
      #     preserve owner (super-user only)
      #
      # --verbose, -v
      #     This option increases the amount of information  the  daemon  logs  during  its  startup
      #     phase.   After  the  client connects, the daemon's verbosity level will be controlled by
      #     the options that the client used and the "max verbosity" setting in the module's  config
      #     section.
      #
      # -n, --dry-run
      #     This  makes rsync perform a trial run that doesn’t make any changes (and produces mostly the same output
      #     as a real run).  It is most commonly used in combination with  the  -v,  --verbose  and/or  -i,  --item‐
      #     ize-changes options to see what an rsync command is going to do before one actually runs it.
      #     The  output  of  --itemize-changes is supposed to be exactly the same on a dry run and a subsequent real
      #     run (barring intentional trickery and system call failures); if it isn’t, that’s a  bug.   Other  output
      #     should  be  mostly unchanged, but may differ in some areas.  Notably, a dry run does not send the actual
      #     data for file transfers, so --progress has no effect,  the  "bytes  sent",  "bytes  received",  "literal
      #     data", and "matched data" statistics are too small, and the "speedup" value is equivalent to a run where
      #     no file transfers were needed.
      #
} # End of function f_rsync_command
#
# +----------------------------------------+
# |         Function f_log_format          |
# +----------------------------------------+
#
#     Rev: 2024-06-13
#  Inputs: $1 - "text", "dialog" or "whiptail" The CLI GUI application in use.
#          $2 - Basename Log file of rsync command (without /var/log/rsync).
#          $3 - Start time.
#          $4 - End time.
#          $5 - SOURCE_DIR.
#          $6 - TARGET_DIR.
#          Rsync log file in /var/log/rsync/$2.
#          THIS_FILE, VERSION.
#    Uses: None.
# Outputs: $LOG_FILE.
#
# Summary: Create standardized formatted log file.
#
# Dependencies: f_message.
#
f_log_format () {
      #
      # ------------------------------
      # Log file format specification.
      # ------------------------------
      #
      # Script: [ NAME OF SCRIPT ] (version $VERSION)
      #
      # [ NAME OF SCRIPT ] started at: Monday June 10, 2024 -- 09:05:01
      # [ NAME OF SCRIPT ] finished at: Monday June 10, 2024 -- 09:05:45
      #
      #  from SOURCE directory:
      # [ $SOURCE_DIR ]
      #
      #    to TARGET directory:
      # [ $TARGET_DIR ]
      #
      #        Log file:
      # [ LOG_FILE.log ]
      # rsync_server_FROM_PC_[ PC_SOURCE ]_SHARE-POINT_[ SOURCE_DIR ]_TIMESTAMP_[ DATE-TIME ].log
      #
      # -------------------------
      # Log of rsync events below
      # -------------------------
      #
      # [ Rsync Events listed here ]
      #
      # ---------------------------
      # End of Log  of rsync events
      # ---------------------------
      #
      echo "Script: $THIS_FILE (version $VERSION)" > $2
      echo >> $2
      echo "$THIS_FILE started at: $3" >> $2
      echo "$THIS_FILE finished at: $4" >> $2
      echo >> $2
      echo "  from SOURCE directory:" >> $2
      echo $5 >> $2
      echo >> $2
      echo "    to TARGET directory:" >> $2
      echo $6 >> $2
      echo >> $2
      echo "               Log file:" >> $2
      echo $2 >> $2
      echo >> $2
      echo "-------------------------" >> $2
      echo "Log of rsync events below" >> $2
      echo "-------------------------" >> $2
      cat /var/log/rsync/$2 >> $2
      echo "--------------------------" >> $2
      echo "End of Log of rsync events" >> $2
      echo "--------------------------" >> $2
      #
} # End of function f_log_format.
#
# +----------------------------------------+
# |         Function f_log_display         |
# +----------------------------------------+
#
#  Inputs: $1 - "text", "dialog" or "whiptail" The CLI GUI application in use.
#          $2 - [OPTIONAL] Log file of rsync command (with directory name).
#                          i.e. /var/log/rsync/[ Log file name ].
#    Uses: X, Y, TEMP_FILE.
# Outputs: None.
#
# Summary: Display latest log file.
#
# Dependencies: f_message, f_select_file.
#
f_log_display () {
      #
      if [ -n "$2" ] ; then
         # If $2 (log file) is already specified, then display.
         TEMP_FILE=$THIS_DIR/$THIS_FILE"_temp.txt"
         #
         # Copy log file to temporary file for use by f_message.
         cp $2 $TEMP_FILE
         #
         f_message $1 "OK" "(use arrow keys to scroll up/down/side-ways)"  $TEMP_FILE
      else
         # View the current log file after rsync. Log file is on back-up media.
         #
         TEMP_FILE=$THIS_DIR/$THIS_FILE"_temp.txt"
         #
         # Show user message explaining where the rsync log file may be found.
         f_message $1 "OK" "Log file directory" "The log file may be in a directory on the back-up media\nor it may be in directory /var/log/rsync on the local PC."
         #
         # User chooses log file, $ANS.
         f_select_file $1 "Select log file" /var/log/rsync 1
         #
         if [ -n "$ANS" ] ; then
            # Copy log file to temporary file for use by f_message.
            cp $ANS $TEMP_FILE
            #
            # Display rsync log file.
            f_message $1 "OK" "View rsync log file" $TEMP_FILE
       else
            f_message $1 "NOK" "Log File Error" "No log file selected."
         fi
      fi
      #
} # End of function f_log_display.
#
# +----------------------------------------+
# |      Function f_file_manager_select    |
# +----------------------------------------+
#
#  Inputs: $1=GUI - "dialog" or "whiptail" The CLI GUI application in use.
#          $2=TARGET_DIR.
#          THIS_DIR, THIS_FILE.
#    Uses: RUNAPP, FILE_MANAGER.
# Outputs: None.
#
# Summary: Run an executable script or script
#
# Dependencies: f_file_manager, f_install_app.
#
f_file_manager_select () {
      #
      # Detect and run a file manager for the appropriate CLI or X-Windows
      # environment.
      f_file_manager $1 $2
      #
      # ERROR=0 when a file manager is detected and run.
      # ERROR=1 a file manager needs to be installed.
      #
      if [ $ERROR -eq 1 ] ; then
         # File Manager (listed in the For-loop) was not automatically detected.
         # A file manager of your choice needs to be installed and run.
         #
         #
         #================================================================================
         # EDIT THE LINE BELOW TO DEFINE THE PREFERRED FILE MANAGER APPLICATION.
         #================================================================================
         #
         #
         FILE_MANAGER="mc"
         #
         # None of the applications are installed so install the preferred app and then run it.
         f_install_app $1 $FILE_MANAGER
      fi
      #
      unset RUNAPP FILE_MANAGER
      #
}  # End of function f_file_manager_select.
#
